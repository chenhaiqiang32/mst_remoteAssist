// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.0
//   protoc               v5.27.1
// source: chatProtocol.proto

/* eslint-disable */
import Long from 'long';
import _m0 from 'protobufjs/minimal';

export const protobufPackage = '';

/** 即时通讯信令协议 0.0.6版本 */

/** 客户端平台 Client */
export enum Client {
  /** SERVER - 服务端类型 */
  SERVER = 0,
  /** IOS - IOS类型 */
  IOS = 1,
  /** ANDROID - 安卓手机类型 */
  ANDROID = 2,
  /** PC - PC Web浏览器 */
  PC = 3,
  /** GLASS - AR Glass类型 */
  GLASS = 4,
  UNRECOGNIZED = -1,
}

export function clientFromJSON(object: any): Client {
  switch (object) {
    case 0:
    case 'SERVER':
      return Client.SERVER;
    case 1:
    case 'IOS':
      return Client.IOS;
    case 2:
    case 'ANDROID':
      return Client.ANDROID;
    case 3:
    case 'PC':
      return Client.PC;
    case 4:
    case 'GLASS':
      return Client.GLASS;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return Client.UNRECOGNIZED;
  }
}

export function clientToJSON(object: Client): string {
  switch (object) {
    case Client.SERVER:
      return 'SERVER';
    case Client.IOS:
      return 'IOS';
    case Client.ANDROID:
      return 'ANDROID';
    case Client.PC:
      return 'PC';
    case Client.GLASS:
      return 'GLASS';
    case Client.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

/** 协议类型 type */
export enum EventType {
  /** LOGIN_REQUEST - 客户端发出的登录事件 & 服务端的登录事件处理响应 */
  LOGIN_REQUEST = 0,
  /** LOGIN_SUCCEED - 登录成功 */
  LOGIN_SUCCEED = 1,
  /** HEARTBEAT_PING - 客户端 与 服务端相互传递的心跳事件 */
  HEARTBEAT_PING = 2,
  /** HEARTBEAT_PONG - 客户端 与 服务端相互传递的心跳事件 */
  HEARTBEAT_PONG = 3,
  /** LOGOUT_REQUEST - 客户端发出的登出事件 & 服务端的登出事件处理响应 */
  LOGOUT_REQUEST = 4,
  /** LOGOUT_SUCCEED - 客户端发出的登出事件 & 服务端的登出事件处理响应 */
  LOGOUT_SUCCEED = 5,
  /** KICK_OUT - 客户端踢下线事件 */
  KICK_OUT = 6,
  /** ACK - 当客户端 或 服务端收到消息时, 回复给发送方的事件 */
  ACK = 7,
  /** TOKEN_EXPIRATION_DATE - Token即将过期事件 不足10分钟时开始以1分钟每次的频率通知 */
  TOKEN_EXPIRATION_DATE = 8,
  /** TOKEN_REFRESH - Token刷新事件 客户端使用新的token刷新登录态 */
  TOKEN_REFRESH = 9,
  /** TOKEN_REFRESHED - Token已刷新事件 服务端响应token刷新成功 */
  TOKEN_REFRESHED = 10,
  /** CHAT_USER_ONLINE - 用户上线事件 */
  CHAT_USER_ONLINE = 11,
  /** CHAT_USER_OFFLINE - 用户下线事件 */
  CHAT_USER_OFFLINE = 12,
  /** CONTACT_UPDATED - 通讯录变化事件 */
  CONTACT_UPDATED = 13,
  /** CHAT_GROUP_CREATED - 群组创建事件 */
  CHAT_GROUP_CREATED = 14,
  /** CHAT_GROUP_INFO_UPDATED - 群组信息更新事件 */
  CHAT_GROUP_INFO_UPDATED = 15,
  /** CHAT_GROUP_MEMBER_INVITED - 群组成员邀请事件 */
  CHAT_GROUP_MEMBER_INVITED = 16,
  /** CHAT_GROUP_MEMBER_REMOVED - 群组成员踢出事件 */
  CHAT_GROUP_MEMBER_REMOVED = 17,
  /** CHAT_GROUP_MEMBER_QUIT - 群成员退出事件 */
  CHAT_GROUP_MEMBER_QUIT = 18,
  /** CHAT_GROUP_MASTER_CHANGED - 群主变更事件 */
  CHAT_GROUP_MASTER_CHANGED = 19,
  /** CHAT_GROUP_DISBANDED - 群组解散事件 */
  CHAT_GROUP_DISBANDED = 20,
  /** CHAT_MESSAGE_SEND - 消息发送事件 */
  CHAT_MESSAGE_SEND = 21,
  /** CHAT_MESSAGE_RECEIVED - 消息接收事件 */
  CHAT_MESSAGE_RECEIVED = 22,
  /** CHAT_MESSAGE_READ - 客户端接受到的消息已读事件 客户端发给服务器 */
  CHAT_MESSAGE_READ = 23,
  UNRECOGNIZED = -1,
}

export function eventTypeFromJSON(object: any): EventType {
  switch (object) {
    case 0:
    case 'LOGIN_REQUEST':
      return EventType.LOGIN_REQUEST;
    case 1:
    case 'LOGIN_SUCCEED':
      return EventType.LOGIN_SUCCEED;
    case 2:
    case 'HEARTBEAT_PING':
      return EventType.HEARTBEAT_PING;
    case 3:
    case 'HEARTBEAT_PONG':
      return EventType.HEARTBEAT_PONG;
    case 4:
    case 'LOGOUT_REQUEST':
      return EventType.LOGOUT_REQUEST;
    case 5:
    case 'LOGOUT_SUCCEED':
      return EventType.LOGOUT_SUCCEED;
    case 6:
    case 'KICK_OUT':
      return EventType.KICK_OUT;
    case 7:
    case 'ACK':
      return EventType.ACK;
    case 8:
    case 'TOKEN_EXPIRATION_DATE':
      return EventType.TOKEN_EXPIRATION_DATE;
    case 9:
    case 'TOKEN_REFRESH':
      return EventType.TOKEN_REFRESH;
    case 10:
    case 'TOKEN_REFRESHED':
      return EventType.TOKEN_REFRESHED;
    case 11:
    case 'CHAT_USER_ONLINE':
      return EventType.CHAT_USER_ONLINE;
    case 12:
    case 'CHAT_USER_OFFLINE':
      return EventType.CHAT_USER_OFFLINE;
    case 13:
    case 'CONTACT_UPDATED':
      return EventType.CONTACT_UPDATED;
    case 14:
    case 'CHAT_GROUP_CREATED':
      return EventType.CHAT_GROUP_CREATED;
    case 15:
    case 'CHAT_GROUP_INFO_UPDATED':
      return EventType.CHAT_GROUP_INFO_UPDATED;
    case 16:
    case 'CHAT_GROUP_MEMBER_INVITED':
      return EventType.CHAT_GROUP_MEMBER_INVITED;
    case 17:
    case 'CHAT_GROUP_MEMBER_REMOVED':
      return EventType.CHAT_GROUP_MEMBER_REMOVED;
    case 18:
    case 'CHAT_GROUP_MEMBER_QUIT':
      return EventType.CHAT_GROUP_MEMBER_QUIT;
    case 19:
    case 'CHAT_GROUP_MASTER_CHANGED':
      return EventType.CHAT_GROUP_MASTER_CHANGED;
    case 20:
    case 'CHAT_GROUP_DISBANDED':
      return EventType.CHAT_GROUP_DISBANDED;
    case 21:
    case 'CHAT_MESSAGE_SEND':
      return EventType.CHAT_MESSAGE_SEND;
    case 22:
    case 'CHAT_MESSAGE_RECEIVED':
      return EventType.CHAT_MESSAGE_RECEIVED;
    case 23:
    case 'CHAT_MESSAGE_READ':
      return EventType.CHAT_MESSAGE_READ;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return EventType.UNRECOGNIZED;
  }
}

export function eventTypeToJSON(object: EventType): string {
  switch (object) {
    case EventType.LOGIN_REQUEST:
      return 'LOGIN_REQUEST';
    case EventType.LOGIN_SUCCEED:
      return 'LOGIN_SUCCEED';
    case EventType.HEARTBEAT_PING:
      return 'HEARTBEAT_PING';
    case EventType.HEARTBEAT_PONG:
      return 'HEARTBEAT_PONG';
    case EventType.LOGOUT_REQUEST:
      return 'LOGOUT_REQUEST';
    case EventType.LOGOUT_SUCCEED:
      return 'LOGOUT_SUCCEED';
    case EventType.KICK_OUT:
      return 'KICK_OUT';
    case EventType.ACK:
      return 'ACK';
    case EventType.TOKEN_EXPIRATION_DATE:
      return 'TOKEN_EXPIRATION_DATE';
    case EventType.TOKEN_REFRESH:
      return 'TOKEN_REFRESH';
    case EventType.TOKEN_REFRESHED:
      return 'TOKEN_REFRESHED';
    case EventType.CHAT_USER_ONLINE:
      return 'CHAT_USER_ONLINE';
    case EventType.CHAT_USER_OFFLINE:
      return 'CHAT_USER_OFFLINE';
    case EventType.CONTACT_UPDATED:
      return 'CONTACT_UPDATED';
    case EventType.CHAT_GROUP_CREATED:
      return 'CHAT_GROUP_CREATED';
    case EventType.CHAT_GROUP_INFO_UPDATED:
      return 'CHAT_GROUP_INFO_UPDATED';
    case EventType.CHAT_GROUP_MEMBER_INVITED:
      return 'CHAT_GROUP_MEMBER_INVITED';
    case EventType.CHAT_GROUP_MEMBER_REMOVED:
      return 'CHAT_GROUP_MEMBER_REMOVED';
    case EventType.CHAT_GROUP_MEMBER_QUIT:
      return 'CHAT_GROUP_MEMBER_QUIT';
    case EventType.CHAT_GROUP_MASTER_CHANGED:
      return 'CHAT_GROUP_MASTER_CHANGED';
    case EventType.CHAT_GROUP_DISBANDED:
      return 'CHAT_GROUP_DISBANDED';
    case EventType.CHAT_MESSAGE_SEND:
      return 'CHAT_MESSAGE_SEND';
    case EventType.CHAT_MESSAGE_RECEIVED:
      return 'CHAT_MESSAGE_RECEIVED';
    case EventType.CHAT_MESSAGE_READ:
      return 'CHAT_MESSAGE_READ';
    case EventType.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

/** 被踢下线的原因 */
export enum KickOutReason {
  /** UNKNOWN - 未知原因 一般是发生了异常 */
  UNKNOWN = 0,
  /** TOKEN_INVALID - Token无效 */
  TOKEN_INVALID = 1,
  /** TOKEN_EXPIRED - token过期 */
  TOKEN_EXPIRED = 2,
  /** DUPLICATE_LOGIN - 重复登录 */
  DUPLICATE_LOGIN = 3,
  /** HEARTBEAT_TIMEOUT - 心跳超时 */
  HEARTBEAT_TIMEOUT = 4,
  /** EVENT_TYPE_INVALID - 事件类型无效 */
  EVENT_TYPE_INVALID = 5,
  /** EVENT_DATA_INVALID - 参数入参校验失败 */
  EVENT_DATA_INVALID = 6,
  /** UNAUTHORIZED_REQUEST - 未授权的事件请求, 一般是在未登录成功时发送了其他事件消息导致的 */
  UNAUTHORIZED_REQUEST = 7,
  /** APP_DISABLED - 此用户的APP被禁用 */
  APP_DISABLED = 8,
  UNRECOGNIZED = -1,
}

export function kickOutReasonFromJSON(object: any): KickOutReason {
  switch (object) {
    case 0:
    case 'UNKNOWN':
      return KickOutReason.UNKNOWN;
    case 1:
    case 'TOKEN_INVALID':
      return KickOutReason.TOKEN_INVALID;
    case 2:
    case 'TOKEN_EXPIRED':
      return KickOutReason.TOKEN_EXPIRED;
    case 3:
    case 'DUPLICATE_LOGIN':
      return KickOutReason.DUPLICATE_LOGIN;
    case 4:
    case 'HEARTBEAT_TIMEOUT':
      return KickOutReason.HEARTBEAT_TIMEOUT;
    case 5:
    case 'EVENT_TYPE_INVALID':
      return KickOutReason.EVENT_TYPE_INVALID;
    case 6:
    case 'EVENT_DATA_INVALID':
      return KickOutReason.EVENT_DATA_INVALID;
    case 7:
    case 'UNAUTHORIZED_REQUEST':
      return KickOutReason.UNAUTHORIZED_REQUEST;
    case 8:
    case 'APP_DISABLED':
      return KickOutReason.APP_DISABLED;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return KickOutReason.UNRECOGNIZED;
  }
}

export function kickOutReasonToJSON(object: KickOutReason): string {
  switch (object) {
    case KickOutReason.UNKNOWN:
      return 'UNKNOWN';
    case KickOutReason.TOKEN_INVALID:
      return 'TOKEN_INVALID';
    case KickOutReason.TOKEN_EXPIRED:
      return 'TOKEN_EXPIRED';
    case KickOutReason.DUPLICATE_LOGIN:
      return 'DUPLICATE_LOGIN';
    case KickOutReason.HEARTBEAT_TIMEOUT:
      return 'HEARTBEAT_TIMEOUT';
    case KickOutReason.EVENT_TYPE_INVALID:
      return 'EVENT_TYPE_INVALID';
    case KickOutReason.EVENT_DATA_INVALID:
      return 'EVENT_DATA_INVALID';
    case KickOutReason.UNAUTHORIZED_REQUEST:
      return 'UNAUTHORIZED_REQUEST';
    case KickOutReason.APP_DISABLED:
      return 'APP_DISABLED';
    case KickOutReason.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

/** 消息类型 */
export enum ChatType {
  PRIVATE_CHAT = 0,
  GROUP_CHAT = 1,
  UNRECOGNIZED = -1,
}

export function chatTypeFromJSON(object: any): ChatType {
  switch (object) {
    case 0:
    case 'PRIVATE_CHAT':
      return ChatType.PRIVATE_CHAT;
    case 1:
    case 'GROUP_CHAT':
      return ChatType.GROUP_CHAT;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return ChatType.UNRECOGNIZED;
  }
}

export function chatTypeToJSON(object: ChatType): string {
  switch (object) {
    case ChatType.PRIVATE_CHAT:
      return 'PRIVATE_CHAT';
    case ChatType.GROUP_CHAT:
      return 'GROUP_CHAT';
    case ChatType.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

/** 消息类型 */
export enum MessageType {
  TEXT = 0,
  IMAGE = 1,
  AUDIO = 2,
  VIDEO = 3,
  FILE = 4,
  SYSTEM = 5,
  UNRECOGNIZED = -1,
}

export function messageTypeFromJSON(object: any): MessageType {
  switch (object) {
    case 0:
    case 'TEXT':
      return MessageType.TEXT;
    case 1:
    case 'IMAGE':
      return MessageType.IMAGE;
    case 2:
    case 'AUDIO':
      return MessageType.AUDIO;
    case 3:
    case 'VIDEO':
      return MessageType.VIDEO;
    case 4:
    case 'FILE':
      return MessageType.FILE;
    case 5:
    case 'SYSTEM':
      return MessageType.SYSTEM;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return MessageType.UNRECOGNIZED;
  }
}

export function messageTypeToJSON(object: MessageType): string {
  switch (object) {
    case MessageType.TEXT:
      return 'TEXT';
    case MessageType.IMAGE:
      return 'IMAGE';
    case MessageType.AUDIO:
      return 'AUDIO';
    case MessageType.VIDEO:
      return 'VIDEO';
    case MessageType.FILE:
      return 'FILE';
    case MessageType.SYSTEM:
      return 'SYSTEM';
    case MessageType.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

/** 顶层协议 */
export interface Protocol {
  /** 事件类型 @See EventType */
  type: number;
  /** 消息指纹 UUID */
  fp: string;
  /** 消息内容 @See **Event */
  event: Uint8Array;
  /** 消息时间戳 */
  timestamp: Long;
}

/** 登录请求事件 type = 0 客户端发给服务器 LOGIN_REQUEST */
export interface LoginRequestEvent {
  userId: Long;
  client: Client;
  /** 登录的token, 用于校验userId和client的有效性 */
  token: string;
  /** 最后一次登录时间 */
  lastLoginTime: Long;
}

/** 登录响应事件 type = 1 服务器发给客户端 LOGIN_SUCCEED */
export interface LoginSucceedEvent {
  /** 最后一次登录时间 后续用于断线重连时携带 */
  lastLoginTime: Long;
}

/** 心跳响应事件 type = 2 客户端发给服务器 HEARTBEAT_PING */
export interface HeartbeatPingEvent {}

/** 心跳响应事件 type = 3 服务器发给客户端 HEARTBEAT_PONG */
export interface HeartbeatPongEvent {}

/** 退出登录请求事件 type = 4 客户端发给服务器 LOGOUT_REQUEST */
export interface LogoutRequestEvent {}

/** 退出登录响应事件 type = 5 服务器发给客户端 LOGOUT_SUCCEED */
export interface LogoutSucceedEvent {}

/** 踢下线事件 type = 6 服务器发给客户端 KICK_OUT */
export interface KickOutEvent {
  /** 被踢下线的原因 */
  reason: KickOutReason;
}

/** ACK事件 type = 7 客户端发给服务器 / 服务器发给客户端 ACK */
export interface AckEvent {
  /** 消息指纹 */
  fp: string;
  /** 消息的入库时间 */
  timestamp: Long;
}

/** Token即将过期事件 type = 8 服务器发给客户端 TOKEN_EXPIRATION_DATE */
export interface TokenExpirationDateEvent {}

/** Token刷新事件 type = 9 客户端发给服务器 TOKEN_REFRESH */
export interface TokenRefreshEvent {
  /** 新的token */
  token: string;
}

/** Token已刷新事件 type = 10 服务器发给客户端 TOKEN_REFRESHED */
export interface TokenRefreshedEvent {}

/** 用户上线事件 type = 11 CHAT_USER_ONLINE 服务器发给客户端 */
export interface UserOnlineEvent {
  /** 用户id */
  userId: Long;
  /** 上线客户端 */
  client: Client;
}

/** 用户下线事件 type = 12 CHAT_USER_OFFLINE 服务器发给客户端 */
export interface UserOfflineEvent {
  /** 用户id */
  userId: Long;
  /** 下线客户端 */
  client: Client;
}

/** 通讯录变更事件 type = 13 服务器发给客户端 客户端收到后, 全量同步通讯录和分组数据 */
export interface ContactUpdatedEvent {}

/** 群组创建事件 CHAT_GROUP_CREATED = 14; 服务器发给客户端 */
export interface GroupCreatedEvent {
  /** 群组id */
  groupId: Long;
  /** 群组名称 */
  groupName: string;
  /** 群组头像 */
  avatarUrl: string;
  /** 群主ID */
  masterId: Long;
  /** 用户id数组 */
  userIds: Long[];
  /** 发生时间戳 */
  timestamp: Long;
}

/** 群组信息更新事件 CHAT_GROUP_INFO_UPDATED = 15; 服务器发给客户端 */
export interface GroupInfoUpdatedEvent {
  /** 群组ID */
  groupId: Long;
  /** 群组名称 */
  groupName: string;
  /** 群组头像 */
  avatarUrl: string;
  /** 更新者ID */
  updatedUserId: Long;
  /** 发生时间戳 */
  timestamp: Long;
}

/** CHAT_GROUP_MEMBER_INVITED = 16; // 群组成员邀请事件 服务器发给客户端 */
export interface GroupMemberInvitedEvent {
  /** 群组ID */
  groupId: Long;
  /** 群组名称 */
  groupName: string;
  /** 群组头像 */
  avatarUrl: string;
  /** 邀请人userId */
  invitorUserId: Long;
  /** 被邀请人userId 数组 */
  invitedUserIds: Long[];
  /** 发生时间戳 */
  timestamp: Long;
}

/** CHAT_GROUP_MEMBER_REMOVED = 17; // 群组成员踢出事件 服务器发给客户端 */
export interface GroupMemberRemovedEvent {
  /** 群组ID */
  groupId: Long;
  /** 群主ID */
  masterId: Long;
  /** 被移除的userId数组 */
  removedUserIds: Long[];
  /** 发生时间戳 */
  timestamp: Long;
}

/** CHAT_GROUP_MEMBER_QUIT = 18; // 群成员退出事件 服务器发给客户端 */
export interface GroupMemberQuitEvent {
  /** 群聊ID */
  groupId: Long;
  /** 退出人userId */
  quitUserId: Long;
  /** 发生时间戳 */
  timestamp: Long;
}

/** CHAT_GROUP_MASTER_CHANGED = 19; // 群主变更事件 */
export interface GroupMasterChangedEvent {
  /** 群组ID */
  groupId: Long;
  /** 旧群主ID */
  oldMasterId: Long;
  /** 新群主ID */
  newMasterId: Long;
  /** 发生时间戳 */
  timestamp: Long;
}

/** CHAT_GROUP_DISBANDED = 20; // 群组解散事件 */
export interface GroupDisbandedEvent {
  groupId: Long;
  masterId: Long;
  /** 发生时间戳 */
  timestamp: Long;
}

/** 发送消息事件 type = 21 客户端发给服务端 */
export interface ChatMessageSendEvent {
  /** 消息接收人 userId / groupId */
  recipientId: Long;
  /** 会话类型 */
  chatType: ChatType;
  /** 消息类型 */
  messageType: MessageType;
  /** 消息正文 */
  content: string;
}

/** 消息接收事件 type = 22 服务端发给客户端 */
export interface ChatMessageReceivedEvent {
  /** 发送人 */
  senderId: Long;
  /** 消息接收人 userId / groupId */
  recipientId: Long;
  /** 会话类型 */
  chatType: ChatType;
  /** 消息类型 */
  messageType: MessageType;
  /** 消息正文 */
  content: string;
  /** 消息发送时间 */
  timestamp: Long;
}

/**
 * CHAT_RECEIVED_MESSAGE_READ = 23; 客户端接受到的消息已读事件 客户端发给服务器
 * 服务器发给客户端
 */
export interface ChatReceivedMessageReadEvent {
  /** 会话类型 */
  chatType: ChatType;
  /** 会话ID，聊天对象ID(单聊时为对方用户ID, 群聊时为群聊ID) */
  targetId: Long;
}

function createBaseProtocol(): Protocol {
  return { type: 0, fp: '', event: new Uint8Array(0), timestamp: Long.ZERO };
}

export const Protocol = {
  encode(
    message: Protocol,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.fp !== '') {
      writer.uint32(18).string(message.fp);
    }
    if (message.event.length !== 0) {
      writer.uint32(26).bytes(message.event);
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Protocol {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtocol();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fp = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.event = reader.bytes();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.timestamp = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Protocol {
    return {
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      fp: isSet(object.fp) ? globalThis.String(object.fp) : '',
      event: isSet(object.event)
        ? bytesFromBase64(object.event)
        : new Uint8Array(0),
      timestamp: isSet(object.timestamp)
        ? Long.fromValue(object.timestamp)
        : Long.ZERO,
    };
  },

  toJSON(message: Protocol): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.fp !== '') {
      obj.fp = message.fp;
    }
    if (message.event.length !== 0) {
      obj.event = base64FromBytes(message.event);
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      obj.timestamp = (message.timestamp || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Protocol>, I>>(base?: I): Protocol {
    return Protocol.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Protocol>, I>>(object: I): Protocol {
    const message = createBaseProtocol();
    message.type = object.type ?? 0;
    message.fp = object.fp ?? '';
    message.event = object.event ?? new Uint8Array(0);
    message.timestamp =
      object.timestamp !== undefined && object.timestamp !== null
        ? Long.fromValue(object.timestamp)
        : Long.ZERO;
    return message;
  },
};

function createBaseLoginRequestEvent(): LoginRequestEvent {
  return { userId: Long.ZERO, client: 0, token: '', lastLoginTime: Long.ZERO };
}

export const LoginRequestEvent = {
  encode(
    message: LoginRequestEvent,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (!message.userId.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.userId);
    }
    if (message.client !== 0) {
      writer.uint32(16).int32(message.client);
    }
    if (message.token !== '') {
      writer.uint32(26).string(message.token);
    }
    if (!message.lastLoginTime.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.lastLoginTime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LoginRequestEvent {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginRequestEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.client = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.token = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.lastLoginTime = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginRequestEvent {
    return {
      userId: isSet(object.userId) ? Long.fromValue(object.userId) : Long.ZERO,
      client: isSet(object.client) ? clientFromJSON(object.client) : 0,
      token: isSet(object.token) ? globalThis.String(object.token) : '',
      lastLoginTime: isSet(object.lastLoginTime)
        ? Long.fromValue(object.lastLoginTime)
        : Long.ZERO,
    };
  },

  toJSON(message: LoginRequestEvent): unknown {
    const obj: any = {};
    if (!message.userId.equals(Long.ZERO)) {
      obj.userId = (message.userId || Long.ZERO).toString();
    }
    if (message.client !== 0) {
      obj.client = clientToJSON(message.client);
    }
    if (message.token !== '') {
      obj.token = message.token;
    }
    if (!message.lastLoginTime.equals(Long.ZERO)) {
      obj.lastLoginTime = (message.lastLoginTime || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginRequestEvent>, I>>(
    base?: I
  ): LoginRequestEvent {
    return LoginRequestEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginRequestEvent>, I>>(
    object: I
  ): LoginRequestEvent {
    const message = createBaseLoginRequestEvent();
    message.userId =
      object.userId !== undefined && object.userId !== null
        ? Long.fromValue(object.userId)
        : Long.ZERO;
    message.client = object.client ?? 0;
    message.token = object.token ?? '';
    message.lastLoginTime =
      object.lastLoginTime !== undefined && object.lastLoginTime !== null
        ? Long.fromValue(object.lastLoginTime)
        : Long.ZERO;
    return message;
  },
};

function createBaseLoginSucceedEvent(): LoginSucceedEvent {
  return { lastLoginTime: Long.ZERO };
}

export const LoginSucceedEvent = {
  encode(
    message: LoginSucceedEvent,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (!message.lastLoginTime.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.lastLoginTime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LoginSucceedEvent {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginSucceedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.lastLoginTime = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginSucceedEvent {
    return {
      lastLoginTime: isSet(object.lastLoginTime)
        ? Long.fromValue(object.lastLoginTime)
        : Long.ZERO,
    };
  },

  toJSON(message: LoginSucceedEvent): unknown {
    const obj: any = {};
    if (!message.lastLoginTime.equals(Long.ZERO)) {
      obj.lastLoginTime = (message.lastLoginTime || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginSucceedEvent>, I>>(
    base?: I
  ): LoginSucceedEvent {
    return LoginSucceedEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginSucceedEvent>, I>>(
    object: I
  ): LoginSucceedEvent {
    const message = createBaseLoginSucceedEvent();
    message.lastLoginTime =
      object.lastLoginTime !== undefined && object.lastLoginTime !== null
        ? Long.fromValue(object.lastLoginTime)
        : Long.ZERO;
    return message;
  },
};

function createBaseHeartbeatPingEvent(): HeartbeatPingEvent {
  return {};
}

export const HeartbeatPingEvent = {
  encode(
    _: HeartbeatPingEvent,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HeartbeatPingEvent {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartbeatPingEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): HeartbeatPingEvent {
    return {};
  },

  toJSON(_: HeartbeatPingEvent): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<HeartbeatPingEvent>, I>>(
    base?: I
  ): HeartbeatPingEvent {
    return HeartbeatPingEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeartbeatPingEvent>, I>>(
    _: I
  ): HeartbeatPingEvent {
    const message = createBaseHeartbeatPingEvent();
    return message;
  },
};

function createBaseHeartbeatPongEvent(): HeartbeatPongEvent {
  return {};
}

export const HeartbeatPongEvent = {
  encode(
    _: HeartbeatPongEvent,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HeartbeatPongEvent {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartbeatPongEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): HeartbeatPongEvent {
    return {};
  },

  toJSON(_: HeartbeatPongEvent): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<HeartbeatPongEvent>, I>>(
    base?: I
  ): HeartbeatPongEvent {
    return HeartbeatPongEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeartbeatPongEvent>, I>>(
    _: I
  ): HeartbeatPongEvent {
    const message = createBaseHeartbeatPongEvent();
    return message;
  },
};

function createBaseLogoutRequestEvent(): LogoutRequestEvent {
  return {};
}

export const LogoutRequestEvent = {
  encode(
    _: LogoutRequestEvent,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LogoutRequestEvent {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogoutRequestEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): LogoutRequestEvent {
    return {};
  },

  toJSON(_: LogoutRequestEvent): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<LogoutRequestEvent>, I>>(
    base?: I
  ): LogoutRequestEvent {
    return LogoutRequestEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogoutRequestEvent>, I>>(
    _: I
  ): LogoutRequestEvent {
    const message = createBaseLogoutRequestEvent();
    return message;
  },
};

function createBaseLogoutSucceedEvent(): LogoutSucceedEvent {
  return {};
}

export const LogoutSucceedEvent = {
  encode(
    _: LogoutSucceedEvent,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LogoutSucceedEvent {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogoutSucceedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): LogoutSucceedEvent {
    return {};
  },

  toJSON(_: LogoutSucceedEvent): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<LogoutSucceedEvent>, I>>(
    base?: I
  ): LogoutSucceedEvent {
    return LogoutSucceedEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogoutSucceedEvent>, I>>(
    _: I
  ): LogoutSucceedEvent {
    const message = createBaseLogoutSucceedEvent();
    return message;
  },
};

function createBaseKickOutEvent(): KickOutEvent {
  return { reason: 0 };
}

export const KickOutEvent = {
  encode(
    message: KickOutEvent,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.reason !== 0) {
      writer.uint32(8).int32(message.reason);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): KickOutEvent {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKickOutEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reason = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KickOutEvent {
    return {
      reason: isSet(object.reason) ? kickOutReasonFromJSON(object.reason) : 0,
    };
  },

  toJSON(message: KickOutEvent): unknown {
    const obj: any = {};
    if (message.reason !== 0) {
      obj.reason = kickOutReasonToJSON(message.reason);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KickOutEvent>, I>>(
    base?: I
  ): KickOutEvent {
    return KickOutEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KickOutEvent>, I>>(
    object: I
  ): KickOutEvent {
    const message = createBaseKickOutEvent();
    message.reason = object.reason ?? 0;
    return message;
  },
};

function createBaseAckEvent(): AckEvent {
  return { fp: '', timestamp: Long.ZERO };
}

export const AckEvent = {
  encode(
    message: AckEvent,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.fp !== '') {
      writer.uint32(10).string(message.fp);
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AckEvent {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAckEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fp = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.timestamp = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AckEvent {
    return {
      fp: isSet(object.fp) ? globalThis.String(object.fp) : '',
      timestamp: isSet(object.timestamp)
        ? Long.fromValue(object.timestamp)
        : Long.ZERO,
    };
  },

  toJSON(message: AckEvent): unknown {
    const obj: any = {};
    if (message.fp !== '') {
      obj.fp = message.fp;
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      obj.timestamp = (message.timestamp || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AckEvent>, I>>(base?: I): AckEvent {
    return AckEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AckEvent>, I>>(object: I): AckEvent {
    const message = createBaseAckEvent();
    message.fp = object.fp ?? '';
    message.timestamp =
      object.timestamp !== undefined && object.timestamp !== null
        ? Long.fromValue(object.timestamp)
        : Long.ZERO;
    return message;
  },
};

function createBaseTokenExpirationDateEvent(): TokenExpirationDateEvent {
  return {};
}

export const TokenExpirationDateEvent = {
  encode(
    _: TokenExpirationDateEvent,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): TokenExpirationDateEvent {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenExpirationDateEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): TokenExpirationDateEvent {
    return {};
  },

  toJSON(_: TokenExpirationDateEvent): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenExpirationDateEvent>, I>>(
    base?: I
  ): TokenExpirationDateEvent {
    return TokenExpirationDateEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenExpirationDateEvent>, I>>(
    _: I
  ): TokenExpirationDateEvent {
    const message = createBaseTokenExpirationDateEvent();
    return message;
  },
};

function createBaseTokenRefreshEvent(): TokenRefreshEvent {
  return { token: '' };
}

export const TokenRefreshEvent = {
  encode(
    message: TokenRefreshEvent,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.token !== '') {
      writer.uint32(10).string(message.token);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TokenRefreshEvent {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenRefreshEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenRefreshEvent {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : '',
    };
  },

  toJSON(message: TokenRefreshEvent): unknown {
    const obj: any = {};
    if (message.token !== '') {
      obj.token = message.token;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenRefreshEvent>, I>>(
    base?: I
  ): TokenRefreshEvent {
    return TokenRefreshEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenRefreshEvent>, I>>(
    object: I
  ): TokenRefreshEvent {
    const message = createBaseTokenRefreshEvent();
    message.token = object.token ?? '';
    return message;
  },
};

function createBaseTokenRefreshedEvent(): TokenRefreshedEvent {
  return {};
}

export const TokenRefreshedEvent = {
  encode(
    _: TokenRefreshedEvent,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TokenRefreshedEvent {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenRefreshedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): TokenRefreshedEvent {
    return {};
  },

  toJSON(_: TokenRefreshedEvent): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenRefreshedEvent>, I>>(
    base?: I
  ): TokenRefreshedEvent {
    return TokenRefreshedEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenRefreshedEvent>, I>>(
    _: I
  ): TokenRefreshedEvent {
    const message = createBaseTokenRefreshedEvent();
    return message;
  },
};

function createBaseUserOnlineEvent(): UserOnlineEvent {
  return { userId: Long.ZERO, client: 0 };
}

export const UserOnlineEvent = {
  encode(
    message: UserOnlineEvent,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (!message.userId.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.userId);
    }
    if (message.client !== 0) {
      writer.uint32(16).int32(message.client);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserOnlineEvent {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserOnlineEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.client = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserOnlineEvent {
    return {
      userId: isSet(object.userId) ? Long.fromValue(object.userId) : Long.ZERO,
      client: isSet(object.client) ? clientFromJSON(object.client) : 0,
    };
  },

  toJSON(message: UserOnlineEvent): unknown {
    const obj: any = {};
    if (!message.userId.equals(Long.ZERO)) {
      obj.userId = (message.userId || Long.ZERO).toString();
    }
    if (message.client !== 0) {
      obj.client = clientToJSON(message.client);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserOnlineEvent>, I>>(
    base?: I
  ): UserOnlineEvent {
    return UserOnlineEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserOnlineEvent>, I>>(
    object: I
  ): UserOnlineEvent {
    const message = createBaseUserOnlineEvent();
    message.userId =
      object.userId !== undefined && object.userId !== null
        ? Long.fromValue(object.userId)
        : Long.ZERO;
    message.client = object.client ?? 0;
    return message;
  },
};

function createBaseUserOfflineEvent(): UserOfflineEvent {
  return { userId: Long.ZERO, client: 0 };
}

export const UserOfflineEvent = {
  encode(
    message: UserOfflineEvent,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (!message.userId.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.userId);
    }
    if (message.client !== 0) {
      writer.uint32(16).int32(message.client);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserOfflineEvent {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserOfflineEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.client = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserOfflineEvent {
    return {
      userId: isSet(object.userId) ? Long.fromValue(object.userId) : Long.ZERO,
      client: isSet(object.client) ? clientFromJSON(object.client) : 0,
    };
  },

  toJSON(message: UserOfflineEvent): unknown {
    const obj: any = {};
    if (!message.userId.equals(Long.ZERO)) {
      obj.userId = (message.userId || Long.ZERO).toString();
    }
    if (message.client !== 0) {
      obj.client = clientToJSON(message.client);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserOfflineEvent>, I>>(
    base?: I
  ): UserOfflineEvent {
    return UserOfflineEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserOfflineEvent>, I>>(
    object: I
  ): UserOfflineEvent {
    const message = createBaseUserOfflineEvent();
    message.userId =
      object.userId !== undefined && object.userId !== null
        ? Long.fromValue(object.userId)
        : Long.ZERO;
    message.client = object.client ?? 0;
    return message;
  },
};

function createBaseContactUpdatedEvent(): ContactUpdatedEvent {
  return {};
}

export const ContactUpdatedEvent = {
  encode(
    _: ContactUpdatedEvent,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ContactUpdatedEvent {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContactUpdatedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ContactUpdatedEvent {
    return {};
  },

  toJSON(_: ContactUpdatedEvent): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ContactUpdatedEvent>, I>>(
    base?: I
  ): ContactUpdatedEvent {
    return ContactUpdatedEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContactUpdatedEvent>, I>>(
    _: I
  ): ContactUpdatedEvent {
    const message = createBaseContactUpdatedEvent();
    return message;
  },
};

function createBaseGroupCreatedEvent(): GroupCreatedEvent {
  return {
    groupId: Long.ZERO,
    groupName: '',
    avatarUrl: '',
    masterId: Long.ZERO,
    userIds: [],
    timestamp: Long.ZERO,
  };
}

export const GroupCreatedEvent = {
  encode(
    message: GroupCreatedEvent,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (!message.groupId.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.groupId);
    }
    if (message.groupName !== '') {
      writer.uint32(18).string(message.groupName);
    }
    if (message.avatarUrl !== '') {
      writer.uint32(26).string(message.avatarUrl);
    }
    if (!message.masterId.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.masterId);
    }
    writer.uint32(42).fork();
    for (const v of message.userIds) {
      writer.int64(v);
    }
    writer.ldelim();
    if (!message.timestamp.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GroupCreatedEvent {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupCreatedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.groupId = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.groupName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.avatarUrl = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.masterId = reader.int64() as Long;
          continue;
        case 5:
          if (tag === 40) {
            message.userIds.push(reader.int64() as Long);

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.userIds.push(reader.int64() as Long);
            }

            continue;
          }

          break;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.timestamp = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupCreatedEvent {
    return {
      groupId: isSet(object.groupId)
        ? Long.fromValue(object.groupId)
        : Long.ZERO,
      groupName: isSet(object.groupName)
        ? globalThis.String(object.groupName)
        : '',
      avatarUrl: isSet(object.avatarUrl)
        ? globalThis.String(object.avatarUrl)
        : '',
      masterId: isSet(object.masterId)
        ? Long.fromValue(object.masterId)
        : Long.ZERO,
      userIds: globalThis.Array.isArray(object?.userIds)
        ? object.userIds.map((e: any) => Long.fromValue(e))
        : [],
      timestamp: isSet(object.timestamp)
        ? Long.fromValue(object.timestamp)
        : Long.ZERO,
    };
  },

  toJSON(message: GroupCreatedEvent): unknown {
    const obj: any = {};
    if (!message.groupId.equals(Long.ZERO)) {
      obj.groupId = (message.groupId || Long.ZERO).toString();
    }
    if (message.groupName !== '') {
      obj.groupName = message.groupName;
    }
    if (message.avatarUrl !== '') {
      obj.avatarUrl = message.avatarUrl;
    }
    if (!message.masterId.equals(Long.ZERO)) {
      obj.masterId = (message.masterId || Long.ZERO).toString();
    }
    if (message.userIds?.length) {
      obj.userIds = message.userIds.map((e) => (e || Long.ZERO).toString());
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      obj.timestamp = (message.timestamp || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupCreatedEvent>, I>>(
    base?: I
  ): GroupCreatedEvent {
    return GroupCreatedEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupCreatedEvent>, I>>(
    object: I
  ): GroupCreatedEvent {
    const message = createBaseGroupCreatedEvent();
    message.groupId =
      object.groupId !== undefined && object.groupId !== null
        ? Long.fromValue(object.groupId)
        : Long.ZERO;
    message.groupName = object.groupName ?? '';
    message.avatarUrl = object.avatarUrl ?? '';
    message.masterId =
      object.masterId !== undefined && object.masterId !== null
        ? Long.fromValue(object.masterId)
        : Long.ZERO;
    message.userIds = object.userIds?.map((e) => Long.fromValue(e)) || [];
    message.timestamp =
      object.timestamp !== undefined && object.timestamp !== null
        ? Long.fromValue(object.timestamp)
        : Long.ZERO;
    return message;
  },
};

function createBaseGroupInfoUpdatedEvent(): GroupInfoUpdatedEvent {
  return {
    groupId: Long.ZERO,
    groupName: '',
    avatarUrl: '',
    updatedUserId: Long.ZERO,
    timestamp: Long.ZERO,
  };
}

export const GroupInfoUpdatedEvent = {
  encode(
    message: GroupInfoUpdatedEvent,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (!message.groupId.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.groupId);
    }
    if (message.groupName !== '') {
      writer.uint32(18).string(message.groupName);
    }
    if (message.avatarUrl !== '') {
      writer.uint32(26).string(message.avatarUrl);
    }
    if (!message.updatedUserId.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.updatedUserId);
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.timestamp);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GroupInfoUpdatedEvent {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupInfoUpdatedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.groupId = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.groupName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.avatarUrl = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.updatedUserId = reader.int64() as Long;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.timestamp = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupInfoUpdatedEvent {
    return {
      groupId: isSet(object.groupId)
        ? Long.fromValue(object.groupId)
        : Long.ZERO,
      groupName: isSet(object.groupName)
        ? globalThis.String(object.groupName)
        : '',
      avatarUrl: isSet(object.avatarUrl)
        ? globalThis.String(object.avatarUrl)
        : '',
      updatedUserId: isSet(object.updatedUserId)
        ? Long.fromValue(object.updatedUserId)
        : Long.ZERO,
      timestamp: isSet(object.timestamp)
        ? Long.fromValue(object.timestamp)
        : Long.ZERO,
    };
  },

  toJSON(message: GroupInfoUpdatedEvent): unknown {
    const obj: any = {};
    if (!message.groupId.equals(Long.ZERO)) {
      obj.groupId = (message.groupId || Long.ZERO).toString();
    }
    if (message.groupName !== '') {
      obj.groupName = message.groupName;
    }
    if (message.avatarUrl !== '') {
      obj.avatarUrl = message.avatarUrl;
    }
    if (!message.updatedUserId.equals(Long.ZERO)) {
      obj.updatedUserId = (message.updatedUserId || Long.ZERO).toString();
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      obj.timestamp = (message.timestamp || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupInfoUpdatedEvent>, I>>(
    base?: I
  ): GroupInfoUpdatedEvent {
    return GroupInfoUpdatedEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupInfoUpdatedEvent>, I>>(
    object: I
  ): GroupInfoUpdatedEvent {
    const message = createBaseGroupInfoUpdatedEvent();
    message.groupId =
      object.groupId !== undefined && object.groupId !== null
        ? Long.fromValue(object.groupId)
        : Long.ZERO;
    message.groupName = object.groupName ?? '';
    message.avatarUrl = object.avatarUrl ?? '';
    message.updatedUserId =
      object.updatedUserId !== undefined && object.updatedUserId !== null
        ? Long.fromValue(object.updatedUserId)
        : Long.ZERO;
    message.timestamp =
      object.timestamp !== undefined && object.timestamp !== null
        ? Long.fromValue(object.timestamp)
        : Long.ZERO;
    return message;
  },
};

function createBaseGroupMemberInvitedEvent(): GroupMemberInvitedEvent {
  return {
    groupId: Long.ZERO,
    groupName: '',
    avatarUrl: '',
    invitorUserId: Long.ZERO,
    invitedUserIds: [],
    timestamp: Long.ZERO,
  };
}

export const GroupMemberInvitedEvent = {
  encode(
    message: GroupMemberInvitedEvent,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (!message.groupId.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.groupId);
    }
    if (message.groupName !== '') {
      writer.uint32(18).string(message.groupName);
    }
    if (message.avatarUrl !== '') {
      writer.uint32(26).string(message.avatarUrl);
    }
    if (!message.invitorUserId.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.invitorUserId);
    }
    writer.uint32(42).fork();
    for (const v of message.invitedUserIds) {
      writer.int64(v);
    }
    writer.ldelim();
    if (!message.timestamp.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.timestamp);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GroupMemberInvitedEvent {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupMemberInvitedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.groupId = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.groupName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.avatarUrl = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.invitorUserId = reader.int64() as Long;
          continue;
        case 5:
          if (tag === 40) {
            message.invitedUserIds.push(reader.int64() as Long);

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.invitedUserIds.push(reader.int64() as Long);
            }

            continue;
          }

          break;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.timestamp = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupMemberInvitedEvent {
    return {
      groupId: isSet(object.groupId)
        ? Long.fromValue(object.groupId)
        : Long.ZERO,
      groupName: isSet(object.groupName)
        ? globalThis.String(object.groupName)
        : '',
      avatarUrl: isSet(object.avatarUrl)
        ? globalThis.String(object.avatarUrl)
        : '',
      invitorUserId: isSet(object.invitorUserId)
        ? Long.fromValue(object.invitorUserId)
        : Long.ZERO,
      invitedUserIds: globalThis.Array.isArray(object?.invitedUserIds)
        ? object.invitedUserIds.map((e: any) => Long.fromValue(e))
        : [],
      timestamp: isSet(object.timestamp)
        ? Long.fromValue(object.timestamp)
        : Long.ZERO,
    };
  },

  toJSON(message: GroupMemberInvitedEvent): unknown {
    const obj: any = {};
    if (!message.groupId.equals(Long.ZERO)) {
      obj.groupId = (message.groupId || Long.ZERO).toString();
    }
    if (message.groupName !== '') {
      obj.groupName = message.groupName;
    }
    if (message.avatarUrl !== '') {
      obj.avatarUrl = message.avatarUrl;
    }
    if (!message.invitorUserId.equals(Long.ZERO)) {
      obj.invitorUserId = (message.invitorUserId || Long.ZERO).toString();
    }
    if (message.invitedUserIds?.length) {
      obj.invitedUserIds = message.invitedUserIds.map((e) =>
        (e || Long.ZERO).toString()
      );
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      obj.timestamp = (message.timestamp || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupMemberInvitedEvent>, I>>(
    base?: I
  ): GroupMemberInvitedEvent {
    return GroupMemberInvitedEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupMemberInvitedEvent>, I>>(
    object: I
  ): GroupMemberInvitedEvent {
    const message = createBaseGroupMemberInvitedEvent();
    message.groupId =
      object.groupId !== undefined && object.groupId !== null
        ? Long.fromValue(object.groupId)
        : Long.ZERO;
    message.groupName = object.groupName ?? '';
    message.avatarUrl = object.avatarUrl ?? '';
    message.invitorUserId =
      object.invitorUserId !== undefined && object.invitorUserId !== null
        ? Long.fromValue(object.invitorUserId)
        : Long.ZERO;
    message.invitedUserIds =
      object.invitedUserIds?.map((e) => Long.fromValue(e)) || [];
    message.timestamp =
      object.timestamp !== undefined && object.timestamp !== null
        ? Long.fromValue(object.timestamp)
        : Long.ZERO;
    return message;
  },
};

function createBaseGroupMemberRemovedEvent(): GroupMemberRemovedEvent {
  return {
    groupId: Long.ZERO,
    masterId: Long.ZERO,
    removedUserIds: [],
    timestamp: Long.ZERO,
  };
}

export const GroupMemberRemovedEvent = {
  encode(
    message: GroupMemberRemovedEvent,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (!message.groupId.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.groupId);
    }
    if (!message.masterId.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.masterId);
    }
    writer.uint32(26).fork();
    for (const v of message.removedUserIds) {
      writer.int64(v);
    }
    writer.ldelim();
    if (!message.timestamp.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.timestamp);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GroupMemberRemovedEvent {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupMemberRemovedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.groupId = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.masterId = reader.int64() as Long;
          continue;
        case 3:
          if (tag === 24) {
            message.removedUserIds.push(reader.int64() as Long);

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.removedUserIds.push(reader.int64() as Long);
            }

            continue;
          }

          break;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.timestamp = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupMemberRemovedEvent {
    return {
      groupId: isSet(object.groupId)
        ? Long.fromValue(object.groupId)
        : Long.ZERO,
      masterId: isSet(object.masterId)
        ? Long.fromValue(object.masterId)
        : Long.ZERO,
      removedUserIds: globalThis.Array.isArray(object?.removedUserIds)
        ? object.removedUserIds.map((e: any) => Long.fromValue(e))
        : [],
      timestamp: isSet(object.timestamp)
        ? Long.fromValue(object.timestamp)
        : Long.ZERO,
    };
  },

  toJSON(message: GroupMemberRemovedEvent): unknown {
    const obj: any = {};
    if (!message.groupId.equals(Long.ZERO)) {
      obj.groupId = (message.groupId || Long.ZERO).toString();
    }
    if (!message.masterId.equals(Long.ZERO)) {
      obj.masterId = (message.masterId || Long.ZERO).toString();
    }
    if (message.removedUserIds?.length) {
      obj.removedUserIds = message.removedUserIds.map((e) =>
        (e || Long.ZERO).toString()
      );
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      obj.timestamp = (message.timestamp || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupMemberRemovedEvent>, I>>(
    base?: I
  ): GroupMemberRemovedEvent {
    return GroupMemberRemovedEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupMemberRemovedEvent>, I>>(
    object: I
  ): GroupMemberRemovedEvent {
    const message = createBaseGroupMemberRemovedEvent();
    message.groupId =
      object.groupId !== undefined && object.groupId !== null
        ? Long.fromValue(object.groupId)
        : Long.ZERO;
    message.masterId =
      object.masterId !== undefined && object.masterId !== null
        ? Long.fromValue(object.masterId)
        : Long.ZERO;
    message.removedUserIds =
      object.removedUserIds?.map((e) => Long.fromValue(e)) || [];
    message.timestamp =
      object.timestamp !== undefined && object.timestamp !== null
        ? Long.fromValue(object.timestamp)
        : Long.ZERO;
    return message;
  },
};

function createBaseGroupMemberQuitEvent(): GroupMemberQuitEvent {
  return { groupId: Long.ZERO, quitUserId: Long.ZERO, timestamp: Long.ZERO };
}

export const GroupMemberQuitEvent = {
  encode(
    message: GroupMemberQuitEvent,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (!message.groupId.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.groupId);
    }
    if (!message.quitUserId.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.quitUserId);
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.timestamp);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GroupMemberQuitEvent {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupMemberQuitEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.groupId = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.quitUserId = reader.int64() as Long;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.timestamp = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupMemberQuitEvent {
    return {
      groupId: isSet(object.groupId)
        ? Long.fromValue(object.groupId)
        : Long.ZERO,
      quitUserId: isSet(object.quitUserId)
        ? Long.fromValue(object.quitUserId)
        : Long.ZERO,
      timestamp: isSet(object.timestamp)
        ? Long.fromValue(object.timestamp)
        : Long.ZERO,
    };
  },

  toJSON(message: GroupMemberQuitEvent): unknown {
    const obj: any = {};
    if (!message.groupId.equals(Long.ZERO)) {
      obj.groupId = (message.groupId || Long.ZERO).toString();
    }
    if (!message.quitUserId.equals(Long.ZERO)) {
      obj.quitUserId = (message.quitUserId || Long.ZERO).toString();
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      obj.timestamp = (message.timestamp || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupMemberQuitEvent>, I>>(
    base?: I
  ): GroupMemberQuitEvent {
    return GroupMemberQuitEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupMemberQuitEvent>, I>>(
    object: I
  ): GroupMemberQuitEvent {
    const message = createBaseGroupMemberQuitEvent();
    message.groupId =
      object.groupId !== undefined && object.groupId !== null
        ? Long.fromValue(object.groupId)
        : Long.ZERO;
    message.quitUserId =
      object.quitUserId !== undefined && object.quitUserId !== null
        ? Long.fromValue(object.quitUserId)
        : Long.ZERO;
    message.timestamp =
      object.timestamp !== undefined && object.timestamp !== null
        ? Long.fromValue(object.timestamp)
        : Long.ZERO;
    return message;
  },
};

function createBaseGroupMasterChangedEvent(): GroupMasterChangedEvent {
  return {
    groupId: Long.ZERO,
    oldMasterId: Long.ZERO,
    newMasterId: Long.ZERO,
    timestamp: Long.ZERO,
  };
}

export const GroupMasterChangedEvent = {
  encode(
    message: GroupMasterChangedEvent,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (!message.groupId.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.groupId);
    }
    if (!message.oldMasterId.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.oldMasterId);
    }
    if (!message.newMasterId.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.newMasterId);
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.timestamp);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GroupMasterChangedEvent {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupMasterChangedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.groupId = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.oldMasterId = reader.int64() as Long;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.newMasterId = reader.int64() as Long;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.timestamp = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupMasterChangedEvent {
    return {
      groupId: isSet(object.groupId)
        ? Long.fromValue(object.groupId)
        : Long.ZERO,
      oldMasterId: isSet(object.oldMasterId)
        ? Long.fromValue(object.oldMasterId)
        : Long.ZERO,
      newMasterId: isSet(object.newMasterId)
        ? Long.fromValue(object.newMasterId)
        : Long.ZERO,
      timestamp: isSet(object.timestamp)
        ? Long.fromValue(object.timestamp)
        : Long.ZERO,
    };
  },

  toJSON(message: GroupMasterChangedEvent): unknown {
    const obj: any = {};
    if (!message.groupId.equals(Long.ZERO)) {
      obj.groupId = (message.groupId || Long.ZERO).toString();
    }
    if (!message.oldMasterId.equals(Long.ZERO)) {
      obj.oldMasterId = (message.oldMasterId || Long.ZERO).toString();
    }
    if (!message.newMasterId.equals(Long.ZERO)) {
      obj.newMasterId = (message.newMasterId || Long.ZERO).toString();
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      obj.timestamp = (message.timestamp || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupMasterChangedEvent>, I>>(
    base?: I
  ): GroupMasterChangedEvent {
    return GroupMasterChangedEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupMasterChangedEvent>, I>>(
    object: I
  ): GroupMasterChangedEvent {
    const message = createBaseGroupMasterChangedEvent();
    message.groupId =
      object.groupId !== undefined && object.groupId !== null
        ? Long.fromValue(object.groupId)
        : Long.ZERO;
    message.oldMasterId =
      object.oldMasterId !== undefined && object.oldMasterId !== null
        ? Long.fromValue(object.oldMasterId)
        : Long.ZERO;
    message.newMasterId =
      object.newMasterId !== undefined && object.newMasterId !== null
        ? Long.fromValue(object.newMasterId)
        : Long.ZERO;
    message.timestamp =
      object.timestamp !== undefined && object.timestamp !== null
        ? Long.fromValue(object.timestamp)
        : Long.ZERO;
    return message;
  },
};

function createBaseGroupDisbandedEvent(): GroupDisbandedEvent {
  return { groupId: Long.ZERO, masterId: Long.ZERO, timestamp: Long.ZERO };
}

export const GroupDisbandedEvent = {
  encode(
    message: GroupDisbandedEvent,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (!message.groupId.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.groupId);
    }
    if (!message.masterId.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.masterId);
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GroupDisbandedEvent {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupDisbandedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.groupId = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.masterId = reader.int64() as Long;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.timestamp = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupDisbandedEvent {
    return {
      groupId: isSet(object.groupId)
        ? Long.fromValue(object.groupId)
        : Long.ZERO,
      masterId: isSet(object.masterId)
        ? Long.fromValue(object.masterId)
        : Long.ZERO,
      timestamp: isSet(object.timestamp)
        ? Long.fromValue(object.timestamp)
        : Long.ZERO,
    };
  },

  toJSON(message: GroupDisbandedEvent): unknown {
    const obj: any = {};
    if (!message.groupId.equals(Long.ZERO)) {
      obj.groupId = (message.groupId || Long.ZERO).toString();
    }
    if (!message.masterId.equals(Long.ZERO)) {
      obj.masterId = (message.masterId || Long.ZERO).toString();
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      obj.timestamp = (message.timestamp || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupDisbandedEvent>, I>>(
    base?: I
  ): GroupDisbandedEvent {
    return GroupDisbandedEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupDisbandedEvent>, I>>(
    object: I
  ): GroupDisbandedEvent {
    const message = createBaseGroupDisbandedEvent();
    message.groupId =
      object.groupId !== undefined && object.groupId !== null
        ? Long.fromValue(object.groupId)
        : Long.ZERO;
    message.masterId =
      object.masterId !== undefined && object.masterId !== null
        ? Long.fromValue(object.masterId)
        : Long.ZERO;
    message.timestamp =
      object.timestamp !== undefined && object.timestamp !== null
        ? Long.fromValue(object.timestamp)
        : Long.ZERO;
    return message;
  },
};

function createBaseChatMessageSendEvent(): ChatMessageSendEvent {
  return { recipientId: Long.ZERO, chatType: 0, messageType: 0, content: '' };
}

export const ChatMessageSendEvent = {
  encode(
    message: ChatMessageSendEvent,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (!message.recipientId.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.recipientId);
    }
    if (message.chatType !== 0) {
      writer.uint32(16).int32(message.chatType);
    }
    if (message.messageType !== 0) {
      writer.uint32(24).int32(message.messageType);
    }
    if (message.content !== '') {
      writer.uint32(34).string(message.content);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ChatMessageSendEvent {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatMessageSendEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.recipientId = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.chatType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.messageType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.content = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatMessageSendEvent {
    return {
      recipientId: isSet(object.recipientId)
        ? Long.fromValue(object.recipientId)
        : Long.ZERO,
      chatType: isSet(object.chatType) ? chatTypeFromJSON(object.chatType) : 0,
      messageType: isSet(object.messageType)
        ? messageTypeFromJSON(object.messageType)
        : 0,
      content: isSet(object.content) ? globalThis.String(object.content) : '',
    };
  },

  toJSON(message: ChatMessageSendEvent): unknown {
    const obj: any = {};
    if (!message.recipientId.equals(Long.ZERO)) {
      obj.recipientId = (message.recipientId || Long.ZERO).toString();
    }
    if (message.chatType !== 0) {
      obj.chatType = chatTypeToJSON(message.chatType);
    }
    if (message.messageType !== 0) {
      obj.messageType = messageTypeToJSON(message.messageType);
    }
    if (message.content !== '') {
      obj.content = message.content;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChatMessageSendEvent>, I>>(
    base?: I
  ): ChatMessageSendEvent {
    return ChatMessageSendEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChatMessageSendEvent>, I>>(
    object: I
  ): ChatMessageSendEvent {
    const message = createBaseChatMessageSendEvent();
    message.recipientId =
      object.recipientId !== undefined && object.recipientId !== null
        ? Long.fromValue(object.recipientId)
        : Long.ZERO;
    message.chatType = object.chatType ?? 0;
    message.messageType = object.messageType ?? 0;
    message.content = object.content ?? '';
    return message;
  },
};

function createBaseChatMessageReceivedEvent(): ChatMessageReceivedEvent {
  return {
    senderId: Long.ZERO,
    recipientId: Long.ZERO,
    chatType: 0,
    messageType: 0,
    content: '',
    timestamp: Long.ZERO,
  };
}

export const ChatMessageReceivedEvent = {
  encode(
    message: ChatMessageReceivedEvent,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (!message.senderId.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.senderId);
    }
    if (!message.recipientId.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.recipientId);
    }
    if (message.chatType !== 0) {
      writer.uint32(24).int32(message.chatType);
    }
    if (message.messageType !== 0) {
      writer.uint32(32).int32(message.messageType);
    }
    if (message.content !== '') {
      writer.uint32(42).string(message.content);
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.timestamp);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ChatMessageReceivedEvent {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatMessageReceivedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.senderId = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.recipientId = reader.int64() as Long;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.chatType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.messageType = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.content = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.timestamp = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatMessageReceivedEvent {
    return {
      senderId: isSet(object.senderId)
        ? Long.fromValue(object.senderId)
        : Long.ZERO,
      recipientId: isSet(object.recipientId)
        ? Long.fromValue(object.recipientId)
        : Long.ZERO,
      chatType: isSet(object.chatType) ? chatTypeFromJSON(object.chatType) : 0,
      messageType: isSet(object.messageType)
        ? messageTypeFromJSON(object.messageType)
        : 0,
      content: isSet(object.content) ? globalThis.String(object.content) : '',
      timestamp: isSet(object.timestamp)
        ? Long.fromValue(object.timestamp)
        : Long.ZERO,
    };
  },

  toJSON(message: ChatMessageReceivedEvent): unknown {
    const obj: any = {};
    if (!message.senderId.equals(Long.ZERO)) {
      obj.senderId = (message.senderId || Long.ZERO).toString();
    }
    if (!message.recipientId.equals(Long.ZERO)) {
      obj.recipientId = (message.recipientId || Long.ZERO).toString();
    }
    if (message.chatType !== 0) {
      obj.chatType = chatTypeToJSON(message.chatType);
    }
    if (message.messageType !== 0) {
      obj.messageType = messageTypeToJSON(message.messageType);
    }
    if (message.content !== '') {
      obj.content = message.content;
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      obj.timestamp = (message.timestamp || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChatMessageReceivedEvent>, I>>(
    base?: I
  ): ChatMessageReceivedEvent {
    return ChatMessageReceivedEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChatMessageReceivedEvent>, I>>(
    object: I
  ): ChatMessageReceivedEvent {
    const message = createBaseChatMessageReceivedEvent();
    message.senderId =
      object.senderId !== undefined && object.senderId !== null
        ? Long.fromValue(object.senderId)
        : Long.ZERO;
    message.recipientId =
      object.recipientId !== undefined && object.recipientId !== null
        ? Long.fromValue(object.recipientId)
        : Long.ZERO;
    message.chatType = object.chatType ?? 0;
    message.messageType = object.messageType ?? 0;
    message.content = object.content ?? '';
    message.timestamp =
      object.timestamp !== undefined && object.timestamp !== null
        ? Long.fromValue(object.timestamp)
        : Long.ZERO;
    return message;
  },
};

function createBaseChatReceivedMessageReadEvent(): ChatReceivedMessageReadEvent {
  return { chatType: 0, targetId: Long.ZERO };
}

export const ChatReceivedMessageReadEvent = {
  encode(
    message: ChatReceivedMessageReadEvent,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.chatType !== 0) {
      writer.uint32(8).int32(message.chatType);
    }
    if (!message.targetId.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.targetId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ChatReceivedMessageReadEvent {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatReceivedMessageReadEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.chatType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.targetId = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatReceivedMessageReadEvent {
    return {
      chatType: isSet(object.chatType) ? chatTypeFromJSON(object.chatType) : 0,
      targetId: isSet(object.targetId)
        ? Long.fromValue(object.targetId)
        : Long.ZERO,
    };
  },

  toJSON(message: ChatReceivedMessageReadEvent): unknown {
    const obj: any = {};
    if (message.chatType !== 0) {
      obj.chatType = chatTypeToJSON(message.chatType);
    }
    if (!message.targetId.equals(Long.ZERO)) {
      obj.targetId = (message.targetId || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChatReceivedMessageReadEvent>, I>>(
    base?: I
  ): ChatReceivedMessageReadEvent {
    return ChatReceivedMessageReadEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChatReceivedMessageReadEvent>, I>>(
    object: I
  ): ChatReceivedMessageReadEvent {
    const message = createBaseChatReceivedMessageReadEvent();
    message.chatType = object.chatType ?? 0;
    message.targetId =
      object.targetId !== undefined && object.targetId !== null
        ? Long.fromValue(object.targetId)
        : Long.ZERO;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, 'base64'));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString('base64');
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(''));
  }
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends Long
  ? string | number | Long
  : T extends globalThis.Array<infer U>
  ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U>
  ? ReadonlyArray<DeepPartial<U>>
  : T extends {}
  ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
